package com.usman
import android.app.Activity
import android.content.ContentUris
import android.content.Context
import android.media.MediaPlayer
import android.os.Bundle
import android.provider.MediaStore
import android.widget.Button
import android.widget.EditText
import android.widget.LinearLayout
import android.widget.TextView
import org.json.JSONArray
import org.json.JSONObject
import java.io.*
import java.net.HttpURLConnection
import java.net.URL
import android.widget.Toast
import android.provider.ContactsContract
import android.content.pm.PackageManager
import android.os.Build
import android.content.Intent
import java.net.URLEncoder
import android.net.Uri
import android.speech.RecognizerIntent
import android.speech.SpeechRecognizer
import android.speech.tts.TextToSpeech
import java.util.*
import java.text.SimpleDateFormat
import kotlin.random.Random
import android.view.View
import android.Manifest
import android.os.*
import android.speech.RecognitionListener
import android.media.AudioManager
import android.widget.SeekBar
import android.widget.ImageButton
import android.graphics.Color
import android.view.Gravity
import android.view.ViewGroup
import android.widget.ScrollView
import android.widget.LinearLayout.LayoutParams
import android.content.ContentValues



class MainActivity : Activity() {

    private var mediaPlayer: MediaPlayer? = null
	var currentVolume = 0.5f  // volume
	
    private val musicList = mutableListOf<Map<String, String>>()
	
	private var  currentIndex = -1
	
	private var command = ""
	
	private var tts: TextToSpeech? = null
	private lateinit var speechRecognizer: SpeechRecognizer
	private lateinit var speechIntent: Intent
	private val RECORD_AUDIO_REQUEST_CODE = 1
	
	
	

    override fun onCreate(savedInstanceState: Bundle?) {
        super.onCreate(savedInstanceState)
        setContentView(R.layout.activity_main)
		

        val musicListLayout = findViewById<LinearLayout>(R.id.musicListLayout)
        val searchEditText = findViewById<EditText>(R.id.queryData)
        val searchButton = findViewById<Button>(R.id.retrieveData)
        
		
		
        showMusicList(this, musicListLayout)

        searchButton.setOnClickListener {
            val query = searchEditText.text.toString().trim()
            if (query.isNotEmpty()) {
                displayMatchingMusic(this, musicListLayout, query)
            }
        }
		
		
		tts = TextToSpeech(this) { status ->
		if (status == TextToSpeech.SUCCESS) {
		tts?.language = Locale.US
		}
		}
		
		
		// Find the buttons in your layout
val previousBtn = findViewById<Button>(R.id.previousBtn)
val nextBtn = findViewById<Button>(R.id.nextBtn)

// Set OnClickListener for Previous button
previousBtn.setOnClickListener {
    playPreviousSong(this)  // Call the playPreviousSong function
}

// Set OnClickListener for Next button
nextBtn.setOnClickListener {
    playNextSong(this)  // Call the playNextSong function
}



// Find the Play/Pause button
val pauseBtn = findViewById<Button>(R.id.pauseBtn)

// Set OnClickListener for the Play/Pause button
pauseBtn.setOnClickListener {
	
    playAndPauseMusic(this)  // Call the playAndPauseMusic function to play or pause
}

val upVol = findViewById<Button>(R.id.upVol)
    upVol.setOnClickListener{
		increaseSystemVolume(this,2)
	}

val downVol = findViewById<Button>(R.id.downVol)
    downVol.setOnClickListener{
		decreaseSystemVolume(this,2)
	}

    val playbackMode = findViewById<Button>(R.id.playbackMode)
	playbackMode.setOnClickListener {
	when (playbackMode.text.toString()) {
	"Loop All" -> playbackMode.text = "Loop Once"
	"Loop Once" -> playbackMode.text = "Shuffle"
	"Shuffle" -> playbackMode.text = "Loop All"
	}
	}
	
	
	
	val muteunmute = findViewById<Button>(R.id.muteunmute)
	muteunmute.setOnClickListener{
		if(muteunmute.text.toString() == "Mute"){
			muteunmute.text = "Unmute"
			muteandUnmute(this,true)
			}else{
				muteunmute.text = "Mute"
				muteandUnmute(this,false)
				}
	}
	
	
	// toggle button
	val toggleButton = findViewById<ImageButton>(R.id.toggleButton)
val toggleMenu = findViewById<LinearLayout>(R.id.toggleMenu)

toggleButton.setOnClickListener {
    if (toggleMenu.visibility == LinearLayout.VISIBLE) {
        toggleMenu.visibility = LinearLayout.GONE
    } else {
        toggleMenu.visibility = LinearLayout.VISIBLE
    }
}


// Home page main 2 buttons 
val musicList = findViewById<Button>(R.id.musicList)
val playList = findViewById<Button>(R.id.playList)
val allPlayLists = findViewById<LinearLayout>(R.id.allPlayLists)
val addNewPlayListBtn = findViewById<Button>(R.id.addNewPlayListBtn)

val addPlayList = findViewById<LinearLayout>(R.id.addPlayList)
    musicList.setOnClickListener{
	         musicListLayout.visibility = View.VISIBLE
			 addPlayList.visibility = View.GONE
	}
	
	playList.setOnClickListener{
	    	 getPlayListNameandShow()
			 addNewPlayListBtn.visibility = View.VISIBLE
			 allPlayLists.visibility = View.VISIBLE
	         musicListLayout.visibility = View.GONE
			 addPlayList.visibility = View.VISIBLE
			 
	
	}
	
		
		
	
	// search Header icon
	val searchIcon = findViewById<ImageButton>(R.id.searchIcon)
	
	val header = findViewById<LinearLayout>(R.id.header)
	
	val searchBar = findViewById<LinearLayout>(R.id.searchBar)
	
	searchIcon.setOnClickListener{
		header.visibility = View.GONE
		searchBar.visibility = View.VISIBLE
	    
		}
	
	// back from searching 	
	val headerBackButton = findViewById<ImageButton>(R.id.headerBackButton)
	headerBackButton.setOnClickListener{
		header.visibility = View.VISIBLE
		searchBar.visibility = View.GONE
		
		}
		
	// add new Playlist Button	
	// alreafy declared above val addNewPlayListBtn = findViewById<Button>(R.id.addNewPlayListBtn)
	val makeNewPlaylist = findViewById<LinearLayout>(R.id.makeNewPlaylist)
	
	addNewPlayListBtn.setOnClickListener{
		
		makeNewPlaylist.visibility = View.VISIBLE
		
		}
		
	// cancel playlist creation button	
	val cancelCreateButton = findViewById<Button>(R.id.cancelCreateButton)
	cancelCreateButton.setOnClickListener{
		makeNewPlaylist.visibility = View.GONE
		
		}
		
	// create new playlist button	
	val addCreateButton = findViewById<Button>(R.id.addCreateButton)
	val newPlayListName = findViewById<EditText>(R.id.newPlayListName)
	
	addCreateButton.setOnClickListener{
		if(newPlayListName.text.toString() == ""){
			Toast.makeText(this,"Please fill the blank field",Toast.LENGTH_LONG).show()
		}else{
		savePlayListName(newPlayListName.text.toString())
		makeNewPlaylist.visibility = View.GONE
		
		
		
		// call this fun to show latest nane
		getPlayListNameandShow()
		}
				
	}
	
	
	
	// show the playList name to ui
	getPlayListNameandShow()
		


// Request microphone permission
if (checkSelfPermission(Manifest.permission.RECORD_AUDIO) != PackageManager.PERMISSION_GRANTED) {
requestPermissions(arrayOf(Manifest.permission.RECORD_AUDIO), RECORD_AUDIO_REQUEST_CODE)
} else {
listenAndHandleCommands()
}

	initCurrentVolume(this)
	      
	
    }
	
	override fun onRequestPermissionsResult(requestCode: Int, permissions: Array<out String>, grantResults: IntArray) {
    if (requestCode == 101 && grantResults.isNotEmpty() && grantResults[0] == PackageManager.PERMISSION_GRANTED) {
        Toast.makeText(this, "Permission granted. Now try delete again.", Toast.LENGTH_SHORT).show()
    } else {
        Toast.makeText(this, "Permission denied", Toast.LENGTH_SHORT).show()
    }
}

override fun onActivityResult(requestCode: Int, resultCode: Int, data: Intent?) {
    if (requestCode == 102) {
        if (resultCode == RESULT_OK) {
            Toast.makeText(this, "Audio deleted", Toast.LENGTH_SHORT).show()
        } else {
            Toast.makeText(this, "Delete canceled", Toast.LENGTH_SHORT).show()
        }
    }
}
	
	
	fun hasAudioPermission(): Boolean {
	return checkSelfPermission(Manifest.permission.READ_EXTERNAL_STORAGE) == PackageManager.PERMISSION_GRANTED
	}
	
	fun requestAudioPermission() {
	requestPermissions(arrayOf(Manifest.permission.READ_EXTERNAL_STORAGE), 101)
	}
	
	private fun speak(text: String) {
    tts?.speak(text, TextToSpeech.QUEUE_FLUSH, null, null)
}

	fun initCurrentVolume(context: Context) {
    val audioManager = context.getSystemService(Context.AUDIO_SERVICE) as AudioManager
    val maxVolume = audioManager.getStreamMaxVolume(AudioManager.STREAM_MUSIC).toFloat()
    val currentSysVolume = audioManager.getStreamVolume(AudioManager.STREAM_MUSIC).toFloat()

    currentVolume = currentSysVolume / maxVolume
    mediaPlayer?.setVolume(currentVolume, currentVolume)
}
	
	fun increaseSystemVolume(context: Context,num : Int) {
		
		
	val audioManager = context.getSystemService(Context.AUDIO_SERVICE) as AudioManager
	val maxVolume = audioManager.getStreamMaxVolume(AudioManager.STREAM_MUSIC)
	val currentVolume = audioManager.getStreamVolume(AudioManager.STREAM_MUSIC)
	
	if (currentVolume < maxVolume) {
	audioManager.setStreamVolume(AudioManager.STREAM_MUSIC, currentVolume + num, AudioManager.FLAG_SHOW_UI)
	
	}
	}
	
	fun decreaseSystemVolume(context: Context , num : Int) {
	val audioManager = context.getSystemService(Context.AUDIO_SERVICE) as AudioManager
	val currentVolume = audioManager.getStreamVolume(AudioManager.STREAM_MUSIC)
	
	if (currentVolume > 0 ) {
	audioManager.setStreamVolume(AudioManager.STREAM_MUSIC, currentVolume - num, AudioManager.FLAG_SHOW_UI)
	
	}
	}
	
	
	fun muteandUnmute(context: Context, flag: Boolean) {
	val audioManager = context.getSystemService(Context.AUDIO_SERVICE) as AudioManager
	val currentVolume = audioManager.getStreamVolume(AudioManager.STREAM_MUSIC)
	
	if (flag) {
	// Mute (decrease to 0)
	decreaseSystemVolume(context, currentVolume)
	} else {
	
	increaseSystemVolume(context, 6)
	}
	}
	

    private fun showMusicList(context: Context, musicLayout: LinearLayout) {
		var index = 0
        val projection = arrayOf(
            MediaStore.Audio.Media._ID,
            MediaStore.Audio.Media.TITLE
        )

        val selection = "${MediaStore.Audio.Media.IS_MUSIC} != 0"

        val cursor = context.contentResolver.query(
            MediaStore.Audio.Media.EXTERNAL_CONTENT_URI,
            projection,
            selection,
            null,
            null
        )

        musicLayout.removeAllViews()
        musicList.clear()

        cursor?.use {
            val idColumn = it.getColumnIndexOrThrow(MediaStore.Audio.Media._ID)
            val titleColumn = it.getColumnIndexOrThrow(MediaStore.Audio.Media.TITLE)

            while (it.moveToNext()) {
                val audioId = it.getLong(idColumn)
                val title = it.getString(titleColumn)
                val audioUri = ContentUris.withAppendedId(
                    MediaStore.Audio.Media.EXTERNAL_CONTENT_URI, audioId
                )

                val dataSet = mapOf("title" to title, "audioId" to audioId.toString())
                musicList.add(dataSet)

                val titleView = TextView(context)
                titleView.text = title
                titleView.textSize = 16f
                titleView.setPadding(16, 16, 16, 16)
				
				var currentindex = index

                titleView.setOnClickListener {
                    playMusicById(context, audioId)
					
					currentIndex = currentindex
					
                }

                musicLayout.addView(titleView)
				index++
            }
        }
    }
	

    private fun displayMatchingMusic(context: Context, musicLayout: LinearLayout, query: String) {
        

        for (item in musicList) {
            val title = item["title"] ?: ""
            val audioId = item["audioId"]?.toLongOrNull()

            if (title.contains(query, ignoreCase = true) && audioId != null) {
                playMusicById(context, audioId)
                break // Play only the first match
            }
        }
    }

    private fun playMusicById(context: Context, audioId: Long) {
	val audioTit = findViewById<TextView>(R.id.auidoTit)
	val playbackMode = findViewById<Button>(R.id.playbackMode)
	val playingStatus = findViewById<LinearLayout>(R.id.playingStatus)
	val seekBar = findViewById<SeekBar>(R.id.seekBar)
	
	mediaPlayer?.let {
	if (it.isPlaying) {
	it.stop()
	it.reset()
	}
	}
	
	val audioUri = ContentUris.withAppendedId(
	MediaStore.Audio.Media.EXTERNAL_CONTENT_URI, audioId
	)
	
	val title = context.contentResolver.query(
	audioUri,
	arrayOf(MediaStore.Audio.Media.TITLE),
	null,
	null,
	null
	)?.use {
	if (it.moveToFirst())
	it.getString(it.getColumnIndexOrThrow(MediaStore.Audio.Media.TITLE))
	else null
	}
	
	playingStatus.visibility = View.VISIBLE
	audioTit.text = title ?: "Unknown Title"
	audioTit.visibility = View.VISIBLE
	
	mediaPlayer = MediaPlayer.create(context, audioUri)
	mediaPlayer?.start()
	
	val pauseBtn = findViewById<Button>(R.id.pauseBtn)
	pauseBtn.text = "Pause ||"
	
	// SeekBar logic
	seekBar.progress = 0
	seekBar.max = 100
	
	val handler = Handler(Looper.getMainLooper())
	val updateSeekBar = object : Runnable {
	override fun run() {
	mediaPlayer?.let {
	if (it.isPlaying) {
	val progress = (it.currentPosition * 100) / it.duration
	seekBar.progress = progress
	handler.postDelayed(this, 500)
	}
	}
	}
	}
	
	handler.post(updateSeekBar)
	
	seekBar.setOnSeekBarChangeListener(object : SeekBar.OnSeekBarChangeListener {
	override fun onProgressChanged(seekBar: SeekBar?, progress: Int, fromUser: Boolean) {
	if (fromUser) {
	mediaPlayer?.seekTo((mediaPlayer!!.duration * progress) / 100)
	}
	}
	
	override fun onStartTrackingTouch(seekBar: SeekBar?) {}
	override fun onStopTrackingTouch(seekBar: SeekBar?) {}
	})
	
	// Handle completion based on playback mode
	mediaPlayer?.setOnCompletionListener {
	when (playbackMode.text.toString()) {
	"Loop All" -> {
	currentIndex = (currentIndex + 1) % musicList.size
	playNextSong(context)
	}
	"Loop Once" -> {
		mediaPlayer?.let {
		it.seekTo(0)
		it.start()
		}
	
	}
	"Shuffle" -> {
	currentIndex = Random.nextInt(0, musicList.size)
	val randomAudioId = musicList[currentIndex]["audioId"]?.toLongOrNull()
	randomAudioId?.let { playMusicById(context, it) }
	}
	}
	
	savePlayedSongQty(context,audioId.toString(),1)
	}
	}
	
	// Array for playlist songs
	val playListSongIndexArray = mutableListOf<Int>()
	var enterPlayList = false
	var playListIndex = -1
	
	fun playPreviousSong(context: Context) {
    if (musicList.isEmpty()) return
	
	
	/*
	if (playListSongIndexArray.isNotEmpty()){
		currentIndex = playListSongIndexArray.size
		
		
		val audioId = musicList[currentIndex]["audioId"]?.toLongOrNull()
    audioId?.let { playMusicById(context, it) }
		
		}
		// break code 
		return
		
		*/

    // If no song played yet, start with the last one
    if (currentIndex < 0) {
		
        currentIndex = (musicList.size - 1)
    } else if (currentIndex > 0) {
		
        currentIndex--
    } else {
        return // Already at the first song, do nothing
    }

    val audioId = musicList[currentIndex]["audioId"]?.toLongOrNull()
    audioId?.let { playMusicById(context, it) }
}
	
	
	
	
	fun playNextSong(context: Context) {
    if (musicList.isEmpty()) return
	/*
	if(playListIndex == -1){
		playListIndex = 0
		currentIndex = playListIndex
		}else if(playListSongIndexArray.size<playListIndex){
			playListIndex++
			currentIndex = playListIndex
			}
			
		else{
		println("Run second block")	
		*/
		

    // First time use: go to the first song
    if (currentIndex == -1 && musicList.isNotEmpty()) {
		
        currentIndex = 0
    } else if (currentIndex < musicList.size - 1) {
		
        currentIndex++
    } 
// 	}

    var audioId = musicList[currentIndex]["audioId"]?.toLongOrNull()
    audioId?.let { playMusicById(context, it) }
}
	
	
	
	
	var currentPosition: Int = 0  // To store the position of the currently playing song

fun playAndPauseMusic(context: Context) {
	// Find the Play/Pause button
val pauseBtn = findViewById<Button>(R.id.pauseBtn)
if (pauseBtn.text.toString() == "Pause ||"){
		pauseBtn.text = "play ▶"
		}else{
			pauseBtn.text = "Pause ||"
		}

if (mediaPlayer == null && musicList.isNotEmpty()) {
if (currentIndex == -1) currentIndex = 0  // Set to first song if not set

val data = musicList[currentIndex]
val audioId = data["audioId"]?.toLongOrNull() ?: return
val audioUri = ContentUris.withAppendedId(MediaStore.Audio.Media.EXTERNAL_CONTENT_URI, audioId)

mediaPlayer = MediaPlayer.create(context, audioUri)
mediaPlayer?.start()

return
}

mediaPlayer?.let {
if (it.isPlaying) {
it.pause()
currentPosition = it.currentPosition


} else {
it.seekTo(currentPosition)
it.start()
}
}
}





private fun listenAndHandleCommands() {
val recognizer = SpeechRecognizer.createSpeechRecognizer(this)
val intent = Intent(RecognizerIntent.ACTION_RECOGNIZE_SPEECH).apply {
putExtra(RecognizerIntent.EXTRA_LANGUAGE_MODEL, RecognizerIntent.LANGUAGE_MODEL_FREE_FORM)
putExtra(RecognizerIntent.EXTRA_LANGUAGE, Locale.getDefault())
}

recognizer.setRecognitionListener(object : RecognitionListener {
override fun onResults(results: Bundle?) {
val matches = results?.getStringArrayList(SpeechRecognizer.RESULTS_RECOGNITION)
val spoken = matches?.get(0)?.lowercase()?.trim() ?: ""
val commands = listOf(
"play music", "pause music", "play next music", "play previous music",
"increase volume", "decrease volume", "mute music", "unmute music"
)

val prompt = """
Match the command: "$spoken" to one of these: $commands.
If it’s close, return only the best matching command from the list — nothing else.
""".trimIndent()

Thread {
try {
val url = URL("https://generativelanguage.googleapis.com/v1beta/models/gemini-2.0-flash:generateContent?key=AIzaSyACmk1CUecfzJ4HyPhywkwi3XugTYQgaTQ")
val conn = url.openConnection() as HttpURLConnection
conn.requestMethod = "POST"
conn.setRequestProperty("Content-Type", "application/json")
conn.doOutput = true

val request = JSONObject().apply {
put("contents", JSONArray().put(
JSONObject().put("parts", JSONArray().put(
JSONObject().put("text", prompt)
))
))
}

conn.outputStream.bufferedWriter().use { it.write(request.toString()) }

val responseText = conn.inputStream.bufferedReader().use { it.readText() }
val json = JSONObject(responseText)
val command = json.getJSONArray("candidates")
.getJSONObject(0)
.getJSONObject("content")
.getJSONArray("parts")
.getJSONObject(0)
.getString("text")
.lowercase().trim()

runOnUiThread {
handleCommand(command)
listenAndHandleCommands()
}

} catch (e: Exception) {
// Offline fallback
val fallback = commands.firstOrNull { spoken.contains(it.split(" ")[0]) } ?: "unknown"
runOnUiThread {
handleCommand(fallback)
findViewById<TextView>(R.id.errorhandler)?.text = "Offline Mode: ${e.message}"
listenAndHandleCommands()
}
}
}.start()
}

override fun onError(error: Int) {
Handler(Looper.getMainLooper()).postDelayed({ recognizer.startListening(intent) }, 1000)
}

override fun onReadyForSpeech(p0: Bundle?) {}
override fun onBeginningOfSpeech() {}
override fun onRmsChanged(p0: Float) {}
override fun onBufferReceived(p0: ByteArray?) {}
override fun onEndOfSpeech() {}
override fun onPartialResults(p0: Bundle?) {}
override fun onEvent(p0: Int, p1: Bundle?) {}
})

recognizer.startListening(intent)
}


private fun handleCommand(cmd: String) {
    when (cmd) {
        "play music", "pause music" -> {
            speak("Audio Toggled")
            playAndPauseMusic(this)
        }
        "mute music" -> {
            speak("Audio Muted")
            muteandUnmute(this, true)
        }
        "unmute music" -> {
            speak("Audio Unmuted")
            muteandUnmute(this, false)
        }
        "play next music" -> {
            speak("Playing Next")
            playNextSong(this)
        }
        "play previous music" -> {
            speak("Playing Previous")
            playPreviousSong(this)
        }
        "increase volume" -> {
            speak("Volume Increased")
            increaseSystemVolume(this, 3)
        }
        "decrease volume" -> {
            speak("Volume Decreased")
            decreaseSystemVolume(this, 3)
        }
        else -> {
            speak("Sorry, I didn't understand")
        }
    }
}


var playName = ""

fun getPlayListNameandShow() {
val allPlayLists = findViewById<LinearLayout>(R.id.allPlayLists)
val addMusicIcon = findViewById<LinearLayout>(R.id.addMusicIcon)
val allPlayListMusics = findViewById<LinearLayout>(R.id.allPlayListMusics)
val addNewPlayListBtn = findViewById<Button>(R.id.addNewPlayListBtn)
allPlayLists.removeAllViews()
allPlayListMusics.removeAllViews()

val file = File(filesDir, "playListName")
if (!file.exists()) return

val list = JSONArray(FileReader(file).readText())

var activePlayLayout: LinearLayout? = null
var activeParentLayout: LinearLayout? = null

for (i in 0 until list.length()) {
val linearLayout = LinearLayout(this).apply {
orientation = LinearLayout.HORIZONTAL
setPadding(16, 16, 16, 16)
}

val colontextView = TextView(this).apply {
text = "="
textSize = 18f
setTextColor(Color.WHITE)
setPadding(20, 20, 20, 20)
setBackgroundColor(Color.parseColor("#3F51B5"))
layoutParams = LinearLayout.LayoutParams(
LinearLayout.LayoutParams.WRAP_CONTENT,
LinearLayout.LayoutParams.WRAP_CONTENT
).apply {
setMargins(16, 16, 16, 16)
}
}

val playListName = list.getString(i)

val textView = TextView(this).apply {
text = playListName
textSize = 18f
setTextColor(Color.WHITE)
setPadding(20, 20, 20, 20)
setBackgroundColor(Color.parseColor("#3F51B5"))
layoutParams = LinearLayout.LayoutParams(
0,
LinearLayout.LayoutParams.WRAP_CONTENT,
1f
).apply {
setMargins(16, 16, 16, 16)
}
gravity = Gravity.CENTER
}

colontextView.setOnClickListener {
activeParentLayout?.removeView(activePlayLayout)

val playlinearLayout = LinearLayout(this).apply {
orientation = LinearLayout.VERTICAL
setPadding(16, 16, 16, 16)
}

val deleteTextView = TextView(this).apply {
text = "Delete"
textSize = 18f
setTextColor(Color.WHITE)
setBackgroundColor(Color.parseColor("#3F51B5"))
layoutParams = LinearLayout.LayoutParams(
LinearLayout.LayoutParams.WRAP_CONTENT,
LinearLayout.LayoutParams.WRAP_CONTENT
)
}

deleteTextView.setOnClickListener {
deletePlayListName(playListName)
getPlayListNameandShow()
}

val changeNameTextView = TextView(this).apply {
text = "Change Name"
textSize = 18f
setTextColor(Color.WHITE)
setBackgroundColor(Color.parseColor("#3F51B5"))
layoutParams = LinearLayout.LayoutParams(
LinearLayout.LayoutParams.WRAP_CONTENT,
LinearLayout.LayoutParams.WRAP_CONTENT
)
}

changeNameTextView.setOnClickListener {
linearLayout.removeView(textView)

val editLayout = LinearLayout(this).apply {
orientation = LinearLayout.VERTICAL
layoutParams = LinearLayout.LayoutParams(
LinearLayout.LayoutParams.MATCH_PARENT,
LinearLayout.LayoutParams.WRAP_CONTENT
)
}

val editText = EditText(this).apply {
setText(playListName)
layoutParams = LinearLayout.LayoutParams(
LinearLayout.LayoutParams.MATCH_PARENT,
LinearLayout.LayoutParams.WRAP_CONTENT
).apply {
setMargins(0, 0, 0, 10)
}
setTextColor(Color.WHITE)
setBackgroundColor(Color.DKGRAY)
}

val buttonLayout = LinearLayout(this).apply {
orientation = LinearLayout.HORIZONTAL
gravity = Gravity.END
}

val tickButton = Button(this).apply {
text = "✔"
textSize = 20f
layoutParams = LinearLayout.LayoutParams(
LinearLayout.LayoutParams.WRAP_CONTENT,
LinearLayout.LayoutParams.WRAP_CONTENT
).apply { setMargins(8, 0, 8, 0) }
}

val crossButton = Button(this).apply {
text = "✖"
textSize = 20f
layoutParams = LinearLayout.LayoutParams(
LinearLayout.LayoutParams.WRAP_CONTENT,
LinearLayout.LayoutParams.WRAP_CONTENT
).apply { setMargins(8, 0, 8, 0) }
}

buttonLayout.addView(tickButton)
buttonLayout.addView(crossButton)
editLayout.addView(editText)
editLayout.addView(buttonLayout)
linearLayout.addView(editLayout, 0)

tickButton.setOnClickListener {
val newName = editText.text.toString().trim()
if (newName.isNotEmpty()) {
renamePlayListFile(playListName, newName)
getPlayListNameandShow()
} else {
Toast.makeText(this, "Name cannot be empty", Toast.LENGTH_SHORT).show()
}
}

crossButton.setOnClickListener {
linearLayout.removeView(editLayout)
linearLayout.addView(textView, 0)
}
}

playlinearLayout.addView(deleteTextView)
playlinearLayout.addView(changeNameTextView)
linearLayout.addView(playlinearLayout)

activePlayLayout = playlinearLayout
activeParentLayout = linearLayout
}


val addSongIconTextView = TextView(this).apply {
text = "Add new Song"
textSize = 16f
setTextColor(Color.BLUE)
setPadding(20, 10, 20, 10)
layoutParams = LinearLayout.LayoutParams(
LinearLayout.LayoutParams.MATCH_PARENT,
LinearLayout.LayoutParams.WRAP_CONTENT
).apply {
setMargins(32, 16, 32, 16)
}
gravity = Gravity.CENTER
}




textView.setOnClickListener {
	
	playName = playListName
allPlayLists.visibility = View.GONE
addNewPlayListBtn.visibility = View.GONE
 allPlayListMusics.removeAllViews()
 
 
		
addSongIconTextView.visibility = View.VISIBLE




addSongIconTextView.setOnClickListener{
	addSongIconTextView.visibility = View.GONE
		
		val titleArray = musicList.map { it["title"] ?: "Unknown" }.toTypedArray()
		
		val selectionLayout = createMultiSelectBar(this,playListName)
		allPlayListMusics.addView(selectionLayout)
	}






val titleArray = musicList.map { it["title"] ?: "Unknown" }.toTypedArray()
	displayPlayListMusics(playName)
	
}
addMusicIcon.addView(addSongIconTextView)
linearLayout.addView(textView)
linearLayout.addView(colontextView)
allPlayLists.addView(linearLayout)
}
}

fun savePlayListName(name: String) {
val file = File(filesDir, "playListName")
val jsonArray = if (file.exists()) {
JSONArray(FileReader(file).readText())
} else {
JSONArray()
}

jsonArray.put(name)

FileWriter(file).use {
it.write(jsonArray.toString())
}

Toast.makeText(this, "Playlist saved", Toast.LENGTH_SHORT).show()
}


fun deletePlayListName(name: String) {
val file = File(filesDir, "playListName")
if (!file.exists()) {
Toast.makeText(this, "File not found", Toast.LENGTH_SHORT).show()
return
}

val list = JSONArray(FileReader(file).readText())
var found = false

for (i in 0 until list.length()) {
if (list.getString(i) == name) {
list.remove(i)
found = true
break
}
}

if (found) {
FileWriter(file).use { it.write(list.toString()) }
Toast.makeText(this, "$name Deleted", Toast.LENGTH_SHORT).show()
} else {
Toast.makeText(this, "No Name matched", Toast.LENGTH_SHORT).show()
}
}



	fun renamePlayListFile(oldName: String, newName: String) {
    val file = File(filesDir, "playListName")
    val array = JSONArray(FileReader(file).readText())
    val newArray = JSONArray()

    for (i in 0 until array.length()) {
        if (array.getString(i) == oldName) newArray.put(newName)
        else newArray.put(array.getString(i))
    }

    file.writeText(newArray.toString())

    val oldFile = File(filesDir, oldName)
    val newFile = File(filesDir, newName)
    if (oldFile.exists()) oldFile.renameTo(newFile)
}


     
fun getTitleFromAudioId(context: Context, audioId: Long): String {
val item = musicList.find {
(it["audioId"] as? String)?.toLongOrNull() == audioId
}
return item?.get("title") as? String ?: "Unknown Title"
}



    // Global variable (place this outside any function)
	val selectedAudioId = mutableSetOf<Long>()
	
	fun createMultiSelectBar(context: Context, fileName: String): LinearLayout {
	
	selectedAudioId.clear()
	
	// Sort musicList by title
	musicList.sortBy { it["title"]?.toString() }
	
	// Safely extract audioIds as Long
	val audioIdArray = musicList.mapNotNull {
	(it["audioId"] as? String)?.toLongOrNull()
	}.toTypedArray()
	
	val mainLayout = LinearLayout(context).apply {
	orientation = LinearLayout.VERTICAL
	layoutParams = LinearLayout.LayoutParams(
	LinearLayout.LayoutParams.MATCH_PARENT,
	LinearLayout.LayoutParams.WRAP_CONTENT
	)
	}
	
	// Buttons: Add and Cancel
	val buttonLayout = LinearLayout(context).apply {
	orientation = LinearLayout.HORIZONTAL
	gravity = Gravity.END
	layoutParams = LinearLayout.LayoutParams(
	LinearLayout.LayoutParams.MATCH_PARENT,
	LinearLayout.LayoutParams.WRAP_CONTENT
	)
	setPadding(10, 10, 10, 10)
	}
	
	val addButton = Button(context).apply { text = "Add" }
	val cancelButton = Button(context).apply { text = "Cancel" }
	
	buttonLayout.addView(addButton)
	buttonLayout.addView(cancelButton)
	mainLayout.addView(buttonLayout)
	
	// Scrollable list layout
	val scrollView = ScrollView(context).apply {
	layoutParams = LinearLayout.LayoutParams(
	LinearLayout.LayoutParams.MATCH_PARENT,
	LinearLayout.LayoutParams.MATCH_PARENT
	)
	}
	
	val listLayout = LinearLayout(context).apply {
	orientation = LinearLayout.VERTICAL
	layoutParams = LinearLayout.LayoutParams(
	LinearLayout.LayoutParams.MATCH_PARENT,
	LinearLayout.LayoutParams.WRAP_CONTENT
	)
	}
	
	val textViews = mutableListOf<TextView>()
	
	for (id in audioIdArray) {
	val textView = TextView(context).apply {
	text = getTitleFromAudioId(context, id)
	textSize = 18f
	setPadding(20, 20, 20, 20)
	setBackgroundColor(Color.LTGRAY)
	setTextColor(Color.BLACK)
	layoutParams = LinearLayout.LayoutParams(
	LinearLayout.LayoutParams.MATCH_PARENT,
	LinearLayout.LayoutParams.WRAP_CONTENT
	)
	
	setOnClickListener {
	if (selectedAudioId.contains(id)) {
	selectedAudioId.remove(id)
	setBackgroundColor(Color.LTGRAY)
	} else {
	selectedAudioId.add(id)
	setBackgroundColor(Color.CYAN)
	}
	}
	}
	
	textViews.add(textView)
	listLayout.addView(textView)
	}
	
	scrollView.addView(listLayout)
	mainLayout.addView(scrollView)
	
	// Button actions
	addButton.setOnClickListener {
	saveSelectedIdToFile(context, fileName)
	mainLayout.removeAllViews()
	displayPlayListMusics(fileName)
	selectedAudioId.clear()
	Toast.makeText(context, "Selection saved", Toast.LENGTH_SHORT).show()
	}
	
	cancelButton.setOnClickListener {
	selectedAudioId.clear()
	displayPlayListMusics(fileName)
	mainLayout.removeAllViews()
	textViews.forEach { it.setBackgroundColor(Color.LTGRAY) }
	Toast.makeText(context, "Selection cleared", Toast.LENGTH_SHORT).show()
	}
	
	return mainLayout
	}
	
	fun saveSelectedIdToFile(context: Context, fileName: String) {
	try {
	val file = File(context.filesDir, fileName)
	val jsonArray = if (file.exists() && file.readText().isNotEmpty()) {
	JSONArray(file.readText())
	} else {
	JSONArray()
	}
	
	// Collect existing IDs into a set
	val existingIds = mutableSetOf<Long>()
	for (i in 0 until jsonArray.length()) {
	existingIds.add(jsonArray.getLong(i))
	}
	
	// Add only new audio IDs
	for (id in selectedAudioId) {
	if (!existingIds.contains(id)) {
	jsonArray.put(id)
	}
	}
	
	// Save back to file
	file.writeText(jsonArray.toString())
	
	Toast.makeText(context, "Id saved to $fileName", Toast.LENGTH_SHORT).show()
	} catch (e: Exception) {
	Toast.makeText(context, "Error saving: ${e.message}", Toast.LENGTH_LONG).show()
	}
	}
	
	
	fun removeIdToFile(context: Context, fileName: String, requestId: Long) {
	try {
	val file = File(context.filesDir, fileName)
	val jsonArray = if (file.exists() && file.readText().isNotEmpty()) {
	JSONArray(file.readText())
	} else {
	JSONArray()
	}
	
	for (i in 0 until jsonArray.length()) {
	val id = jsonArray.getLong(i)
	if (id == requestId) {
	jsonArray.remove(i)
	break // Stop loop since the ID is unique and now removed
	}
	}
	
	file.writeText(jsonArray.toString())
	Toast.makeText(context, "Id removed from $fileName", Toast.LENGTH_SHORT).show()
	} catch (e: Exception) {
	Toast.makeText(context, "Error removing ID: ${e.message}", Toast.LENGTH_LONG).show()
	}
	}
	
	
	
	fun deleteAudioById(audioId: Long) {
	val audioUri = ContentUris.withAppendedId(MediaStore.Audio.Media.EXTERNAL_CONTENT_URI, audioId)
	
	if (!hasAudioPermission()) {
	requestAudioPermission()
	return
	}
	
	if (Build.VERSION.SDK_INT >= Build.VERSION_CODES.R) {
	try {
	val sender = MediaStore.createDeleteRequest(contentResolver, listOf(audioUri)).intentSender
	startIntentSenderForResult(sender, 102, null, 0, 0, 0)
	} catch (e: Exception) {
	Toast.makeText(this, "Error: ${e.message}", Toast.LENGTH_LONG).show()
	}
	} else {
	val deleted = contentResolver.delete(audioUri, null, null)
	Toast.makeText(this, "Deleted: $deleted", Toast.LENGTH_SHORT).show()
	}
	}
	
	
	
	
	fun renameAudioFileById(context: Context, audioId: Long, newName: String): Boolean {
    val uri = ContentUris.withAppendedId(MediaStore.Audio.Media.EXTERNAL_CONTENT_URI, audioId)

    val contentValues = ContentValues().apply {
        put(MediaStore.Audio.Media.DISPLAY_NAME, newName)  // New file name
    }

    return try {
        val rowsUpdated = context.contentResolver.update(uri, contentValues, null, null)
        rowsUpdated > 0
    } catch (e: Exception) {
        e.printStackTrace()
        false
    }
}
	
	
	
	
	
	fun displaySavedTitlesFromFile(context: Context, fileName: String) {
		playListSongIndexArray.clear()
	try {
	val file = File(context.filesDir, fileName)
	if (!file.exists()) {
	Toast.makeText(context, "No saved data found", Toast.LENGTH_SHORT).show()
	return
	}
	
	// Read and parse indices from file
	val savedData = file.readText()
	val indexList = savedData
	.split(",")
	.mapNotNull { it.trim().toIntOrNull() }
	
	// Convert musicList to titleArray
	val titleArray = musicList.map { it["title"] ?: "Unknown" }.toTypedArray()
	
	// Create a vertical layout for displaying titles
	val resultLayout = LinearLayout(context).apply {
	orientation = LinearLayout.VERTICAL
	setPadding(20, 20, 20, 20)
	}
	
	// Add each matched title
	for (index in indexList) {
		playListSongIndexArray.add(index)
	if (index in titleArray.indices) {
	val titleView = TextView(context).apply {
	text = titleArray[index]
	textSize = 16f
	setPadding(10, 10, 10, 10)
	}
	resultLayout.addView(titleView)
	}
	}
	
	// Add resultLayout to root view
	val rootView = (context as Activity).findViewById<ViewGroup>(android.R.id.content)
	rootView.addView(resultLayout)
	
	} catch (e: Exception) {
	Toast.makeText(context, "Error loading saved titles: ${e.message}", Toast.LENGTH_LONG).show()
	}
	}
	
	
	fun displayPlayListMusics(playName: String) {
	val allPlayListMusics = findViewById<LinearLayout>(R.id.allPlayListMusics)
	allPlayListMusics.removeAllViews()
	
	val addNewMusicsTextView = TextView(this).apply {
	text = "Add New Musics"
	textSize = 16f
	setTextColor(Color.parseColor("#33B5E5"))
	setPadding(20, 20, 20, 20)
	paint.isUnderlineText = true
	gravity = Gravity.CENTER
	layoutParams = LinearLayout.LayoutParams(
	LinearLayout.LayoutParams.MATCH_PARENT,
	LinearLayout.LayoutParams.WRAP_CONTENT
	)
	setOnClickListener {
	allPlayListMusics.removeAllViews()
	allPlayListMusics.addView(createMultiSelectBar(context, playName))
	Toast.makeText(context, "Add New Musics Clicked", Toast.LENGTH_SHORT).show()
	}
	}
	allPlayListMusics.addView(addNewMusicsTextView)
	
	val playListFile = File(filesDir, playName)
	if (playListFile.exists()) {
	val content = playListFile.readText()
	if (content.isNotEmpty()) {
	val songArray = JSONArray(content)
	for (j in 0 until songArray.length()) {
	val savedAudioId = songArray.getLong(j)
	
	val matchedSong = musicList.find {
	(it["audioId"] as? String)?.toLongOrNull() == savedAudioId
	}
	
	val songTitle = matchedSong?.get("title")?.toString() ?: "Unknown"
	
	// Outer vertical layout
	val songRowLayout = LinearLayout(this).apply {
	orientation = LinearLayout.VERTICAL
	setPadding(16, 16, 16, 16)
	layoutParams = LinearLayout.LayoutParams(
	LinearLayout.LayoutParams.MATCH_PARENT,
	LinearLayout.LayoutParams.WRAP_CONTENT
	).apply {
	setMargins(16, 8, 16, 8)
	}
	setBackgroundColor(Color.parseColor("#F8F8F8"))
	}
	
	// Main horizontal row
	val contentRow = LinearLayout(this).apply {
	orientation = LinearLayout.HORIZONTAL
	gravity = Gravity.CENTER_VERTICAL
	}
	
	val songTextView = TextView(this).apply {
	text = songTitle
	textSize = 16f
	setTextColor(Color.BLACK)
	layoutParams = LinearLayout.LayoutParams(0, LinearLayout.LayoutParams.WRAP_CONTENT, 1f)
	setOnClickListener {
	val audioId = matchedSong?.get("audioId")?.toString()?.toLongOrNull()
	if (audioId != null) {
	playMusicById(context, audioId)
	}
	}
	}
	
	// ⋮ options button
	val optionsButton = TextView(this).apply {
	text = "⋮"
	textSize = 20f
	setPadding(20, 0, 20, 0)
	setTextColor(Color.GRAY)
	layoutParams = LinearLayout.LayoutParams(
	LinearLayout.LayoutParams.WRAP_CONTENT,
	LinearLayout.LayoutParams.WRAP_CONTENT
	)
	}
	
	// Hidden button bar below song row
	val buttonBar = LinearLayout(this).apply {
	orientation = LinearLayout.HORIZONTAL
	visibility = View.GONE
	layoutParams = LinearLayout.LayoutParams(
	LinearLayout.LayoutParams.WRAP_CONTENT,
	LinearLayout.LayoutParams.WRAP_CONTENT
	)
	setPadding(0, 8, 0, 0)
	}
	
	val removeButton = Button(this).apply {
	text = "Remove"
	textSize = 14f
	setTextColor(Color.WHITE)
	setBackgroundColor(Color.RED)
	}
	
	removeButton.setOnClickListener {
	removeIdToFile(this, playName, savedAudioId)
	displayPlayListMusics(playName)
	}
	
	val deleteButton = Button(this).apply {
	text = "Delete"
	textSize = 14f
	setTextColor(Color.WHITE)
	setBackgroundColor(Color.parseColor("#D32F2F"))
	}
	
	deleteButton.setOnClickListener {
	deleteAudioById(savedAudioId)
	removeIdToFile(this, playName, savedAudioId)
	displayPlayListMusics(playName)
	}
	
	val editButton = Button(this).apply {
	text = "Edit"
	textSize = 14f
	setTextColor(Color.WHITE)
	setBackgroundColor(Color.parseColor("#1976D2"))
	}
	
	editButton.setOnClickListener {
	// Replace songTextView with edit layout
	val index = contentRow.indexOfChild(songTextView)
	contentRow.removeView(songTextView)
	
	val editLayout = LinearLayout(this).apply {
	orientation = LinearLayout.VERTICAL
	layoutParams = LinearLayout.LayoutParams(
	LinearLayout.LayoutParams.MATCH_PARENT,
	LinearLayout.LayoutParams.WRAP_CONTENT
	)
	}
	
	val editText = EditText(this).apply {
	setText(songTitle)
	layoutParams = LinearLayout.LayoutParams(
	LinearLayout.LayoutParams.MATCH_PARENT,
	LinearLayout.LayoutParams.WRAP_CONTENT
	)
	}
	
	val buttonRow = LinearLayout(this).apply {
	orientation = LinearLayout.HORIZONTAL
	gravity = Gravity.END
	layoutParams = LinearLayout.LayoutParams(
	LinearLayout.LayoutParams.MATCH_PARENT,
	LinearLayout.LayoutParams.WRAP_CONTENT
	)
	}
	
	val cancelButton = Button(this).apply {
	text = "Cancel"
	}
	
	val saveButton = Button(this).apply {
	text = "Save"
	}
	
	buttonRow.addView(cancelButton)
	buttonRow.addView(saveButton)
	
	editLayout.addView(editText)
	editLayout.addView(buttonRow)
	
	contentRow.addView(editLayout, index)
	
	cancelButton.setOnClickListener {
	contentRow.removeView(editLayout)
	contentRow.addView(songTextView, index)
	buttonBar.visibility = View.GONE
	}
	
	saveButton.setOnClickListener {
	val newTitle = editText.text.toString().trim()
	if (newTitle.isNotEmpty()) {
	renameAudioFileById(this,savedAudioId, newTitle)
	songTextView.text = newTitle
	}
	contentRow.removeView(editLayout)
	contentRow.addView(songTextView, index)
	buttonBar.visibility = View.GONE
	Toast.makeText(this, "Title updated", Toast.LENGTH_SHORT).show()
	// Optionally refresh list:
	// displayPlayListMusics(playName)
	}
	}
	
	buttonBar.addView(removeButton)
	buttonBar.addView(deleteButton)
	buttonBar.addView(editButton)
	
	optionsButton.setOnClickListener {
	buttonBar.visibility = if (buttonBar.visibility == View.GONE) View.VISIBLE else View.GONE
	}
	
	contentRow.addView(songTextView)
	contentRow.addView(optionsButton)
	
	songRowLayout.addView(contentRow)
	songRowLayout.addView(buttonBar)
	
	allPlayListMusics.addView(songRowLayout)
	}
	}
	}
	}


     fun savePlayedSongQty(context: Context, id: String, playedTime: Int) {
	 try {
	 val file = File(context.filesDir, "playedSong.json")
	 val jsonArray = if (file.exists() && file.readText().isNotEmpty()) {
	 JSONArray(file.readText())
	 } else {
	 JSONArray()
	 }
	 
	 // Create a proper JSON object
	 val playedObject = JSONObject().apply {
	 put("id", id)
	 put("playedTime", playedTime)
	 }
	 
	 jsonArray.put(playedObject)
	 
	 // Save updated data
	 file.writeText(jsonArray.toString())
	 
	 Toast.makeText(context, "Data saved to ${file.name}", Toast.LENGTH_SHORT).show()
	 } catch (e: Exception) {
	 Toast.makeText(context, "Error saving: ${e.message}", Toast.LENGTH_LONG).show()
	 }
	 }


     fun getPlayedTimeById(context: Context, id: String): Int? {
    return try {
        val file = File(context.filesDir, "playedSong.json")
        if (!file.exists() || file.readText().isEmpty()) return null

        val jsonArray = JSONArray(file.readText())
        for (i in 0 until jsonArray.length()) {
            val obj = jsonArray.getJSONObject(i)
            if (obj.getString("id") == id) {
                return obj.getInt("playedTime")
            }
        }

        null // If not found
    } catch (e: Exception) {
        e.printStackTrace()
        null
    }
}
	 
	 
	 
	 
	 
	 
	 
	 
	 
	 
	 
	 
	 
	 















	
}
